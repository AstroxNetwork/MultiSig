// This file is generated by Umi automatically
// DO NOT CHANGE IT MANUALLY!
import React, { useEffect, useMemo, useState } from 'react';
import { IRoute } from '@/routes/renderRoutes/renderRoutes';
import { useAccess, useAccessMarkedRoutes } from '@/components/Access';
import RightContent from '@/components/RightContent';
import Exception from '@/components/Exception';
import { useDispatch } from 'react-redux';
import { Link, useHistory, useLocation } from 'react-router-dom';
import { IConnector } from '@connect2ic/core'
import { useConnect, useWallet } from '@connect2ic/react'
import { MeResponse, _SERVICE as storeService } from '@/canisters/ego_store';
import { _SERVICE as bucketService } from '@/canisters/ego_bucket';
import { idlFactory as storeIdl } from '@/canisters/ego_store.idl';
import { idlFactory as bucketIdl } from '@/canisters/ego_bucket.idl';
// import { matchRoutes } from 'react-router';
import routes from '@/routes/routes';
import { ProLayout } from '@ant-design/pro-components';
import { BucketConnection } from '@/services/connection/bucket';
import { StoreConnection } from '@/services/connection/store';
import { ActorSubclass } from '@dfinity/agent';
import { useSelector } from 'react-redux';
import { RootDispatch, RootState } from '@/store';
import { getUserInfo } from '@/services/api';
import { YWZResponse } from '@/services';
import { ArrowLeftOutlined } from '@ant-design/icons';




const loginPath = '/home';

export interface InitialStateType {
  loading?: boolean;
  currentUser?: IConnector | undefined;
  isAuthenticated?: () => Promise<boolean | undefined>;
  bucketConnection?: BucketConnection | undefined;
  storeConnection?: StoreConnection | undefined;
  // storeActor?: ActorSubclass<storeService> | undefined;
  // bucketActor?: ActorSubclass<bucketService> | undefined;
}

// // 过滤出需要显示的路由, 这里的filterFn 指 不希望显示的层级
const filterRoutes = (routes: IRoute[], filterFn: (route: IRoute) => boolean) => {
  if (routes.length === 0) {
    return []
  }

  let newRoutes: IRoute[] = []
  for (const route of routes) {
    if (filterFn(route)) {
      if (Array.isArray(route.routes)) {
        newRoutes.push(...filterRoutes(route.routes, filterFn))
      }
    } else {
      newRoutes.push(route);
      if (Array.isArray(route.routes)) {
        route.routes = filterRoutes(route.routes, filterFn);
      }
    }
  }

  return newRoutes;
}

// 格式化路由 处理因 wrapper 导致的 菜单 path 不一致
const mapRoutes = (routes: IRoute[]) => {
  if (routes.length === 0) {
    return []
  }
  return routes.map(route => {
    // 需要 copy 一份, 否则会污染原始数据
    const newRoute = { ...route }
    if (route.originPath) {
      newRoute.path = route.originPath
    }

    if (Array.isArray(route.routes)) {
      newRoute.routes = mapRoutes(route.routes);
    }

    return newRoute
  })
}

export default (props: any) => {
  const location = useLocation();
  const { isConnected, activeProvider,  } = useConnect()
  const [walletProvider] = useWallet()
  const history = useHistory();
  const dispatch = useDispatch<RootDispatch>();
  const slideMode = useSelector((state: RootState) => state.app.slideMode)
  const access = useAccess();
  const [initEnd, setInitEnd] = useState(false)
  const { user } = useSelector((state: RootState) => state.global)
  const clientRoutes = mapRoutes(routes)
  const [menuRoute] = useAccessMarkedRoutes([clientRoutes.find(route => route.path === '/') as IRoute]);
  const matchedRoute = useMemo(() => {
    const routes = filterRoutes(clientRoutes, (curRoute: IRoute) => {
      return !!curRoute.routes && curRoute.routes.length > 0
    })
    return routes.find(route => route.path === location.pathname);
  }, [location.pathname]);
  const runtimeConfig = {
    key: 'layout',
    type: 'modify',
    initialValue: {
    },
  }

  useEffect(() => {
    // userLayout   getInitialState
    if(isConnected) {
      console.log(activeProvider)
      console.log(walletProvider)
      // const bucketConnection = BucketConnection.create(.i)
      dispatch.global.save({
        initialState: {
          currentUser: activeProvider,
          // bucketConnection: BucketConnection,
          // storeConnection: StoreConnection,
        }
      })
    }
  }, [isConnected])

  console.log('menuRoute', menuRoute)
  return (
    <ProLayout
      route={slideMode === 'group' ? menuRoute.routes?.find(route => route.path!.indexOf('group') > -1) : menuRoute.routes?.find(route => route.path!.indexOf('wallet') > -1)}
      title={'Multi-sig'}
      navTheme="light"
      siderWidth={256}
      onMenuHeaderClick={(e) => {
        e.stopPropagation();
        e.preventDefault();
        history.push('/');
      }}
      // formatMessage={userConfig.formatMessage || formatMessage}
      // menu={{ locale: userConfig.locale }}
      logo={null}
      // menuExtraRender={() => {
      //   return (
      //     <div>
      //       Group
      //     </div>
      //   )
      // }}
      menuHeaderRender={() => {
        return (
          <>
            {
              slideMode === 'group' ? (
                <div>
                  Group header
                </div>
              ): (
                <div>
                  <ArrowLeftOutlined onClick={()=> {
                    history.goBack()
                    dispatch.app.save({ slideMode: 'group'})
                  }} />
                  <div className='mt-3'>
                    Wallet header
                  </div>
                </div>
              )
            }
          </>
        )
      }}
      menuItemRender={(menuItemProps, defaultDom) => {
        // console.log('menuItemRender', menuItemProps, defaultDom);
        if (menuItemProps.isUrl || menuItemProps.children) {
          return defaultDom;
        }
        if (menuItemProps.path && location.pathname !== menuItemProps.path) {
          return (
            // handle wildcard route path, for example /slave/* from qiankun
            <Link to={menuItemProps.path.replace('/*', '')} target={menuItemProps.target}>
              {defaultDom}
            </Link>
          );
        }
        return defaultDom
      }}
      fixSiderbar
      fixedHeader
      layout="mix"
      // splitMenus
      {...runtimeConfig}
      rightContentRender={() => <RightContent />}
    >
      <Exception
        route={matchedRoute}
      // notFound={runtimeConfig.notFound}
      // noAccessible={runtimeConfig.noAccessible}
      >
        {props.children
        }
      </Exception>
    </ProLayout>
  );
}
